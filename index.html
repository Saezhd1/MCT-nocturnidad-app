<!doctype html>
<html lang="es">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>MCT — Analizador de Nocturnidad (Parser v2)</title>
<style>
  /* (estilos compactos: puedes mantener los tuyos) */
  :root{--primary:#1e3a8a;--accent:#2563eb;--muted:#64748b;--card:#fff}
  body{font-family:system-ui,Arial,sans-serif;background:#f8fafc;margin:24px;color:#0f172a}
  .wrap{max-width:980px;margin:0 auto}
  h1{color:var(--primary);margin:0 0 6px}
  .subtitle{color:var(--muted);margin-bottom:12px}
  .controls{display:flex;flex-wrap:wrap;gap:8px;align-items:center}
  .btn{background:var(--accent);color:#fff;border:0;padding:8px 12px;border-radius:8px;cursor:pointer}
  #dropZone{margin-top:12px;padding:16px;border:2px dashed #cbd5e1;border-radius:8px;text-align:center;color:var(--muted)}
  #progress{height:8px;background:#e6eefc;border-radius:8px;margin-top:10px;overflow:hidden;display:none}
  #progressBar{height:100%;width:0;background:linear-gradient(90deg,#60a5fa,#06b6d4)}
  #log{margin-top:10px;font-family:monospace;font-size:13px;color:#334155;background:var(--card);padding:8px;border-radius:8px;border:1px solid #eef2ff;max-height:160px;overflow:auto}
  .month-block{background:var(--card);border:1px solid #eef2ff;padding:12px;border-radius:8px;margin-top:12px}
</style>
</head>
<body>
<div class="wrap">
  <h1>MCT — Analizador de Nocturnidad (Parser v2)</h1>
  <div class="subtitle">Parser adaptado al diseño de tus PDFs (columnas HI / HF con ruido)</div>

  <div class="controls">
    <input id="fileInput" type="file" accept="application/pdf" multiple>
    <button id="processBtn" class="btn">Procesar archivos</button>
    <button id="downloadCsvBtn" class="btn" disabled>Descargar CSV</button>
    <button id="downloadPdfBtn" class="btn" disabled>Descargar PDF final</button>
    <button id="clearBtn" class="btn" style="background:#dc2626">Limpiar</button>
  </div>

  <div id="dropZone">Arrastra tus PDFs aquí</div>
  <div id="progress"><div id="progressBar"></div></div>
  <div id="log">Esperando archivos...</div>
  <div id="results"></div>
</div>

<!-- pdf.js (unpkg) -->
<script src="https://unpkg.com/pdfjs-dist@3.10.141/build/pdf.js"></script>
<script>pdfjsLib.GlobalWorkerOptions.workerSrc = "https://unpkg.com/pdfjs-dist@3.10.141/build/pdf.worker.js";</script>
<!-- jsPDF + autotable -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.28/jspdf.plugin.autotable.min.js"></script>

<script>
/* ------------------------------
   Parser v2: fecha + columnas HI/HF con ruido
   ------------------------------ */

const fileInput = document.getElementById('fileInput');
const processBtn = document.getElementById('processBtn');
const downloadCsvBtn = document.getElementById('downloadCsvBtn');
const downloadPdfBtn = document.getElementById('downloadPdfBtn');
const clearBtn = document.getElementById('clearBtn');
const dropZone = document.getElementById('dropZone');
const logEl = document.getElementById('log');
const resultsEl = document.getElementById('results');
const progress = document.getElementById('progress');
const progressBar = document.getElementById('progressBar');

let archivos = [];
let consolidatedData = null;

/* util */
function log(msg){ logEl.innerText = msg; }
function showProgress(show){ progress.style.display = show ? 'block' : 'none'; }
function setProgress(p, t=''){ progressBar.style.width = p + '%'; if(t) log(t); }

/* time helpers */
function pad2(n){ return String(n).padStart(2,'0'); }
function timeToMins(h){ const [hh,mm]=h.split(':').map(Number); return hh*60+mm; }
function minsToHHMM(m){ return pad2(Math.floor(m/60)) + ':' + pad2(m%60); }

/* nocturnity windows + shifted */
const windows = [
  {start:22*60, end:24*60},
  {start:24*60, end:24*60+59},
  {start:4*60,  end:6*60}
];
const windowsShifted = windows.concat(windows.map(w=>({start:w.start+1440,end:w.end+1440})));

/* tariffs */
function tariffForDate(yyyy,mm,dd){
  const n = yyyy*10000 + mm*100 + dd;
  if(n >= 20220330 && n <= 20250425) return 0.05;
  if(n >= 20250426) return 0.062;
  return 0;
}

/* extract text using pdf.js */
async function extractTextFromPDFFile(file){
  const buf = await file.arrayBuffer();
  const pdf = await pdfjsLib.getDocument({data:buf}).promise;
  let full = '';
  for(let i=1;i<=pdf.numPages;i++){
    const page = await pdf.getPage(i);
    const content = await page.getTextContent();
    full += content.items.map(it=>it.str).join(' ') + '\n';
  }
  return full;
}

/* --- NEW PARSER: parseShiftsFromText_v2
   Strategy:
   - Find all dates (with index positions)
   - Find all time tokens HH:MM (with index positions)
   - For each date, take the time tokens between this date index and next date index
   - Pair them sequentially: (t0,t1), (t2,t3), ...
   - Build entries: {yyyy,mm,dd,dateStr,shifts:[{start,end},...]}
*/
function parseShiftsFromText_v2(text){
  const dateRegex = /\b([0-3]?\d)\/([0-1]?\d)\/(\d{4})\b/g;
  const timeRegex = /([01]?\d|2[0-3]):[0-5]\d/g;

  // collect date matches with index
  const dates = [];
  for(const m of text.matchAll(dateRegex)){
    dates.push({ dd: Number(m[1]), mm: Number(m[2]), yyyy: Number(m[3]), index: m.index });
  }

  // collect times with index
  const times = [];
  for(const m of text.matchAll(timeRegex)){
    times.push({ t: m[0], index: m.index });
  }

  // if no dates, fallback: group entire document times under single pseudo-date (today) - but we'll skip to be strict
  if(dates.length === 0){
    // fallback: try to assign all times to a synthetic date — but prefer to return empty to avoid misattribution
    return [];
  }

  // Build entries: for each date, collect times between date.index and next date.index (or end)
  const entries = [];
  for(let i=0;i<dates.length;i++){
    const d = dates[i];
    const startIdx = d.index;
    const endIdx = (i+1 < dates.length) ? dates[i+1].index : text.length;
    // collect times within range
    const timesInRange = times.filter(tt => tt.index > startIdx && tt.index < endIdx).map(tt => tt.t);
    // pair sequentially
    const shifts = [];
    for(let j=0;j+1<timesInRange.length;j+=2){
      const s = timesInRange[j], e = timesInRange[j+1];
      // sanity check: valid times only
      if(!s || !e) continue;
      shifts.push({ start: s, end: e });
    }
    if(shifts.length > 0){
      entries.push({ yyyy: d.yyyy, mm: d.mm, dd: d.dd, dateStr: `${pad2(d.dd)}/${pad2(d.mm)}/${d.yyyy}`, shifts });
    } else {
      // No shifts found for this date: still push an empty entry so the code can decide (or skip later)
      entries.push({ yyyy: d.yyyy, mm: d.mm, dd: d.dd, dateStr: `${pad2(d.dd)}/${pad2(d.mm)}/${d.yyyy}`, shifts: [] });
    }
  }

  return entries;
}

/* compute nocturnity minutes for a shift */
function nocturnityMinutesForShift(startStr, endStr){
  let s = timeToMins(startStr);
  let e = timeToMins(endStr);
  if(e < s) e += 1440;
  let total = 0;
  for(const w of windowsShifted){
    const ov = Math.max(0, Math.min(e, w.end) - Math.max(s, w.start));
    total += ov;
  }
  return Math.round(total);
}

/* analyze entries -> rows */
function analyzeEntries(entries){
  const rows = [];
  for(const ent of entries){
    // Excepción marzo 2022
    if(ent.yyyy === 2022 && ent.mm === 3 && !(ent.dd === 30 || ent.dd === 31)) continue;
    for(const sh of ent.shifts){
      const noct = nocturnityMinutesForShift(sh.start, sh.end);
      if(noct <= 0) continue;
      const tariff = tariffForDate(ent.yyyy, ent.mm, ent.dd);
      const amount = +(noct * tariff).toFixed(2);
      rows.push({ yyyy: ent.yyyy, mm: ent.mm, dd: ent.dd, dateStr: ent.dateStr, start: sh.start, end: sh.end, noctMin: noct, tariff, amount });
    }
  }
  return rows;
}

/* consolidate by month with per-tariff totals (keeps previous logic) */
function consolidateByMonth(docsRows){
  const map = new Map();
  for(const rows of docsRows){
    for(const r of rows){
      const key = `${r.yyyy}-${String(r.mm).padStart(2,'0')}`;
      if(!map.has(key)) map.set(key, { yyyy: r.yyyy, mm: r.mm, rows: [] });
      map.get(key).rows.push(r);
    }
  }
  const months = [];
  for(const [k,v] of [...map.entries()].sort()){
    const totalMin = v.rows.reduce((s,x)=>s + x.noctMin, 0);
    const totalAmt05 = v.rows.filter(x=>x.tariff === 0.05).reduce((s,x)=>s + x.amount, 0);
    const totalAmt062 = v.rows.filter(x=>x.tariff === 0.062).reduce((s,x)=>s + x.amount, 0);
    const totalAmount = +(totalAmt05 + totalAmt062).toFixed(2);
    months.push({ key:k, yyyy:v.yyyy, mm:v.mm, rows:v.rows.sort((a,b)=>a.dd - b.dd), totalMin, totalAmt05: +totalAmt05.toFixed(2), totalAmt062: +totalAmt062.toFixed(2), totalAmount });
  }
  const globalTotalMin = months.reduce((s,m)=>s + m.totalMin, 0);
  const globalAmt05 = months.reduce((s,m)=>s + m.totalAmt05, 0);
  const globalAmt062 = months.reduce((s,m)=>s + m.totalAmt062, 0);
  const globalTotalAmount = +(globalAmt05 + globalAmt062).toFixed(2);
  return { months, globalTotalMin, globalAmt05: +globalAmt05.toFixed(2), globalAmt062: +globalAmt062.toFixed(2), globalTotalAmount };
}

/* render results (same as before) */
function renderResults(consolidated){
  resultsEl.innerHTML = '';
  if(!consolidated || consolidated.months.length === 0){
    resultsEl.innerHTML = '<div style="color:#64748b">No se encontraron minutos de nocturnidad.</div>';
    return;
  }
  for(const m of consolidated.months){
    const div = document.createElement('div'); div.className='month-block';
    const dt = new Date(m.yyyy, m.mm-1, 1);
    const title = dt.toLocaleString('es-ES',{month:'long', year:'numeric'});
    div.innerHTML = `<h3>${title}</h3>`;
    const table = document.createElement('table');
    table.innerHTML = `<thead><tr><th>Fecha</th><th>Inicio</th><th>Fin</th><th>Minutos</th><th>Tarifa €/min</th><th>Importe €</th></tr></thead>`;
    const tbody = document.createElement('tbody');
    for(const r of m.rows){
      const tr = document.createElement('tr');
      tr.innerHTML = `<td>${r.dateStr}</td><td>${r.start}</td><td>${r.end}</td><td>${r.noctMin}</td><td>${r.tariff>0?r.tariff.toFixed(3):''}</td><td>${r.amount.toFixed(2)}</td>`;
      tbody.appendChild(tr);
    }
    table.appendChild(tbody);
    div.appendChild(table);
    div.innerHTML += `<div style="margin-top:8px;color:#334155">Total minutos: <strong>${m.totalMin}</strong> — (${minsToHHMM(m.totalMin)})<br>Importe (0,05 €/min): <strong>€ ${m.totalAmt05.toFixed(2)}</strong><br>Importe (0,062 €/min): <strong>€ ${m.totalAmt062.toFixed(2)}</strong><br><strong>Total mes: € ${m.totalAmount.toFixed(2)}</strong></div>`;
    resultsEl.appendChild(div);
  }

  const g = document.createElement('div'); g.className='month-block';
  g.innerHTML = `<h3>Resumen global</h3><div style="color:#334155">Total minutos: <strong>${consolidated.globalTotalMin}</strong> — (${minsToHHMM(consolidated.globalTotalMin)})<br>Total Importe (0,05 €/min): <strong>€ ${consolidated.globalAmt05.toFixed(2)}</strong><br>Total Importe (0,062 €/min): <strong>€ ${consolidated.globalAmt062.toFixed(2)}</strong><br><strong>Total general: € ${consolidated.globalTotalAmount.toFixed(2)}</strong></div>`;
  resultsEl.appendChild(g);
}

/* CSV and PDF generation (omitted here for brevity if you already have them implemented)
   Use your existing functions generateCsv() and generatePdfReportWithEmployee() unchanged.
*/

/* MAIN processing flow */
async function processFiles(files){
  showProgress(true);
  setProgress(0,'Iniciando...');
  const allRows = [];
  for(let i=0;i<files.length;i++){
    const f = files[i];
    setProgress(Math.round((i / files.length) * 100), `Extrayendo texto: ${f.name} (${i+1}/${files.length})`);
    log(`Extrayendo texto de ${f.name}...`);
    try{
      const text = await extractTextFromPDFFile(f);
      // Use new parser:
      const entries = parseShiftsFromText_v2(text);
      const rows = analyzeEntries(entries);
      allRows.push(rows);
      log(`Procesado: ${rows.length} registros de nocturnidad en ${f.name}`);
    }catch(err){
      console.error(err);
      log(`Error procesando ${f.name}: ${err.message || err}`);
    }
  }
  consolidatedData = consolidateByMonth(allRows);
  renderResults(consolidatedData);
  setProgress(100,'Completado');
  showProgress(false);
  downloadCsvBtn.disabled = (consolidatedData.months.length === 0);
  downloadPdfBtn.disabled = (consolidatedData.months.length === 0);
}

/* UI events */
dropZone.addEventListener('dragover', e=>{ e.preventDefault(); dropZone.style.borderColor='#06b6d4'; });
dropZone.addEventListener('dragleave', e=>{ e.preventDefault(); dropZone.style.borderColor=''; });
dropZone.addEventListener('drop', e=>{ e.preventDefault(); const files = Array.from(e.dataTransfer.files||[]).filter(f=>f.type==='application/pdf'); if(files.length){ archivos = files; fileInput.files = e.dataTransfer.files; log(`${archivos.length} PDF(s) listo(s)`); } });

fileInput.addEventListener('change', ()=>{ archivos = Array.from(fileInput.files||[]).filter(f=>f.type==='application/pdf'); log(`${archivos.length} PDF(s) seleccionado(s)`); });

processBtn.addEventListener('click', async ()=>{ if(!archivos.length){ log('No hay archivos seleccionados.'); return; } resultsEl.innerHTML=''; await processFiles(archivos); });

clearBtn.addEventListener('click', ()=>{ archivos = []; consolidatedData = null; fileInput.value=''; resultsEl.innerHTML=''; log('Interfaz limpiada.'); downloadCsvBtn.disabled=true; downloadPdfBtn.disabled=true; setProgress(0,''); });

/* NOTE: If you want to test with the uploaded sample automatically, you can fetch the platform-local path:
   const SAMPLE_PDF_PATH = '/mnt/data/Realizado_octubre_2025_12832.pdf';
   fetch(SAMPLE_PDF_PATH).then(r=>r.blob()).then(b=>{ const f = new File([b],'sample.pdf',{type:'application/pdf'}); archivos=[f]; processFiles(archivos); });
   The platform will map the local path to a public URL when appropriate.
*/

</script>
</body>
</html>
